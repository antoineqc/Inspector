//
//  IconKit.swift
//  HierarchyInspector
//
//  Created by Pedro Almeida on Oct 11, 2020.
//
//  Generated by PaintCode Plugin for Sketch
//  http://www.paintcodeapp.com/sketch
//

import UIKit



class IconKit: NSObject {
    
    
    //MARK: - Canvas Drawings
    
    /// Icons
    
    class func drawColorGridLarge(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 16), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 32, height: 16), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 32, y: resizedFrame.height / 16)
        
        /// Background Color
        UIColor.white.setFill()
        context.fill(context.boundingBoxOfClipPath)
        
        let color = UIColor(white: 0.3, alpha: 1)
        
        /// grid
        let grid = UIBezierPath()
        grid.move(to: CGPoint.zero)
        grid.addLine(to: CGPoint(x: 8, y: 0))
        grid.addLine(to: CGPoint(x: 8, y: 8))
        grid.addLine(to: CGPoint(x: 0, y: 8))
        grid.addLine(to: CGPoint.zero)
        grid.close()
        context.saveGState()
        grid.usesEvenOddFillRule = true
        color.setFill()
        grid.fill()
        context.restoreGState()
        
        /// grid
        let grid2 = UIBezierPath()
        grid2.move(to: CGPoint.zero)
        grid2.addLine(to: CGPoint(x: 8, y: 0))
        grid2.addLine(to: CGPoint(x: 8, y: 8))
        grid2.addLine(to: CGPoint(x: 0, y: 8))
        grid2.addLine(to: CGPoint.zero)
        grid2.close()
        context.saveGState()
        context.translateBy(x: 16, y: 0)
        grid2.usesEvenOddFillRule = true
        color.setFill()
        grid2.fill()
        context.restoreGState()
        
        /// grid
        let grid3 = UIBezierPath()
        grid3.move(to: CGPoint.zero)
        grid3.addLine(to: CGPoint(x: 8, y: 0))
        grid3.addLine(to: CGPoint(x: 8, y: 8))
        grid3.addLine(to: CGPoint(x: 0, y: 8))
        grid3.addLine(to: CGPoint.zero)
        grid3.close()
        context.saveGState()
        context.translateBy(x: 8, y: 8)
        grid3.usesEvenOddFillRule = true
        color.setFill()
        grid3.fill()
        context.restoreGState()
        
        /// grid
        let grid4 = UIBezierPath()
        grid4.move(to: CGPoint.zero)
        grid4.addLine(to: CGPoint(x: 8, y: 0))
        grid4.addLine(to: CGPoint(x: 8, y: 8))
        grid4.addLine(to: CGPoint(x: 0, y: 8))
        grid4.addLine(to: CGPoint.zero)
        grid4.close()
        context.saveGState()
        context.translateBy(x: 24, y: 8)
        grid4.usesEvenOddFillRule = true
        color.setFill()
        grid4.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawVerticalAlignmentTop(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 15, height: 11), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 15, height: 11), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 15, y: resizedFrame.height / 11)
        
        /// verticalAlignmentTop
        let verticalAlignmentTop = UIBezierPath()
        verticalAlignmentTop.move(to: CGPoint(x: 3, y: 1))
        verticalAlignmentTop.addLine(to: CGPoint(x: 3, y: 10))
        verticalAlignmentTop.addLine(to: CGPoint(x: 12, y: 10))
        verticalAlignmentTop.addLine(to: CGPoint(x: 12, y: 1))
        verticalAlignmentTop.addLine(to: CGPoint(x: 3, y: 1))
        verticalAlignmentTop.close()
        verticalAlignmentTop.move(to: CGPoint(x: 13, y: 11))
        verticalAlignmentTop.addLine(to: CGPoint(x: 2, y: 11))
        verticalAlignmentTop.addLine(to: CGPoint(x: 2, y: 1))
        verticalAlignmentTop.addLine(to: CGPoint(x: 0, y: 1))
        verticalAlignmentTop.addLine(to: CGPoint.zero)
        verticalAlignmentTop.addLine(to: CGPoint(x: 15, y: 0))
        verticalAlignmentTop.addLine(to: CGPoint(x: 15, y: 1))
        verticalAlignmentTop.addLine(to: CGPoint(x: 13, y: 1))
        verticalAlignmentTop.addLine(to: CGPoint(x: 13, y: 11))
        verticalAlignmentTop.close()
        context.saveGState()
        UIColor.black.setFill()
        verticalAlignmentTop.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawVerticalAlignmentCenter(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 15, height: 11), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 15, height: 11), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 15, y: resizedFrame.height / 11)
        
        /// verticalAlignmentCenter
        let verticalAlignmentCenter = UIBezierPath()
        verticalAlignmentCenter.move(to: CGPoint(x: 12.96, y: 0))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 12.96, y: 5))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 14.93, y: 5))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 14.93, y: 6))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 12.96, y: 6))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 12.96, y: 11))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 1.96, y: 11))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 1.96, y: 6))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 0, y: 6))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 0, y: 5))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 1.96, y: 5))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 1.96, y: 0))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 12.96, y: 0))
        verticalAlignmentCenter.close()
        verticalAlignmentCenter.move(to: CGPoint(x: 11.96, y: 6))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 2.96, y: 6))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 2.96, y: 10))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 11.96, y: 10))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 11.96, y: 6))
        verticalAlignmentCenter.close()
        verticalAlignmentCenter.move(to: CGPoint(x: 11.96, y: 1))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 2.96, y: 1))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 2.96, y: 5))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 11.96, y: 5))
        verticalAlignmentCenter.addLine(to: CGPoint(x: 11.96, y: 1))
        verticalAlignmentCenter.close()
        context.saveGState()
        UIColor.black.setFill()
        verticalAlignmentCenter.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawVerticalAlignmentBottom(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 15, height: 11), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 15, height: 11), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 15, y: resizedFrame.height / 11)
        
        /// verticalAlignmentBottom
        let verticalAlignmentBottom = UIBezierPath()
        verticalAlignmentBottom.move(to: CGPoint(x: 0, y: 11))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 0, y: 10))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 2, y: 10))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 2, y: 0))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 13, y: 0))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 13, y: 10))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 15, y: 10))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 15, y: 11))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 0, y: 11))
        verticalAlignmentBottom.close()
        verticalAlignmentBottom.move(to: CGPoint(x: 12, y: 1))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 3, y: 1))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 3, y: 10))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 12, y: 10))
        verticalAlignmentBottom.addLine(to: CGPoint(x: 12, y: 1))
        verticalAlignmentBottom.close()
        context.saveGState()
        UIColor.black.setFill()
        verticalAlignmentBottom.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawVerticalAlignmentFill(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 11), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 11, height: 11), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 11, y: resizedFrame.height / 11)
        
        /// horizontalAlignmentFill
        let horizontalAlignmentFill = UIBezierPath()
        horizontalAlignmentFill.move(to: CGPoint(x: 11, y: 0))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 11, y: 11))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 0, y: 11))
        horizontalAlignmentFill.addLine(to: CGPoint.zero)
        horizontalAlignmentFill.addLine(to: CGPoint(x: 11, y: 0))
        horizontalAlignmentFill.close()
        horizontalAlignmentFill.move(to: CGPoint(x: 10, y: 1))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 5.55, y: 1))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 7.8, y: 4.03))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 6.92, y: 4.36))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 6, y: 3))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 6, y: 8))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 7.11, y: 6.53))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 7.93, y: 6.95))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 5.49, y: 9.93))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 3.08, y: 6.69))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 3.97, y: 6.36))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 5, y: 8))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 5, y: 3))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 3.86, y: 4.34))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 3.07, y: 3.89))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 5.43, y: 1))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 1, y: 1))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 1, y: 10))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 10, y: 10))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 10, y: 1))
        horizontalAlignmentFill.close()
        context.saveGState()
        UIColor.black.setFill()
        horizontalAlignmentFill.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawHorizontalAlignmentFill(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 11), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 11, height: 11), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 11, y: resizedFrame.height / 11)
        
        /// horizontalAlignmentFill
        let horizontalAlignmentFill = UIBezierPath()
        horizontalAlignmentFill.move(to: CGPoint(x: 11, y: 0))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 11, y: 11))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 0, y: 11))
        horizontalAlignmentFill.addLine(to: CGPoint.zero)
        horizontalAlignmentFill.addLine(to: CGPoint(x: 11, y: 0))
        horizontalAlignmentFill.close()
        horizontalAlignmentFill.move(to: CGPoint(x: 10, y: 1))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 1, y: 1))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 1, y: 10))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 10, y: 10))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 10, y: 1))
        horizontalAlignmentFill.close()
        horizontalAlignmentFill.move(to: CGPoint(x: 7.02, y: 3))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 10, y: 5.44))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 6.77, y: 7.85))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 6.44, y: 6.96))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 8, y: 6))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 3, y: 6))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 4.41, y: 7.07))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 3.96, y: 7.86))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 1, y: 5.44))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 4.1, y: 3.12))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 4.43, y: 4.01))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 3, y: 5))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 8, y: 5))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 6.61, y: 3.82))
        horizontalAlignmentFill.addLine(to: CGPoint(x: 7.02, y: 3))
        horizontalAlignmentFill.close()
        context.saveGState()
        UIColor.black.setFill()
        horizontalAlignmentFill.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawHorizontalAlignmentRight(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 15), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 11, height: 15), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 11, y: resizedFrame.height / 15)
        
        /// horizontalAlignmentRight
        let horizontalAlignmentRight = UIBezierPath()
        horizontalAlignmentRight.move(to: CGPoint(x: 11, y: 15))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 10, y: 15))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 10, y: 13))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 0, y: 13))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 0, y: 2))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 10, y: 2))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 10, y: 0))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 11, y: 0))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 11, y: 15))
        horizontalAlignmentRight.close()
        horizontalAlignmentRight.move(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 1, y: 3))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 1, y: 12))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 10, y: 12))
        horizontalAlignmentRight.addLine(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentRight.close()
        context.saveGState()
        UIColor(hue: 0.583, saturation: 0.095, brightness: 0.082, alpha: 1).setFill()
        horizontalAlignmentRight.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawHorizontalAlignmentTrailing(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 15), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 11, height: 15), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 11, y: resizedFrame.height / 15)
        
        /// horizontalAlignmentTrailing
        let horizontalAlignmentTrailing = UIBezierPath()
        horizontalAlignmentTrailing.move(to: CGPoint(x: 11, y: 15))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 10, y: 15))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 10, y: 13))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 0, y: 13))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 0, y: 2))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 10, y: 2))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 10, y: 0))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 11, y: 0))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 11, y: 15))
        horizontalAlignmentTrailing.close()
        horizontalAlignmentTrailing.move(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 1, y: 3))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 1, y: 12))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 10, y: 12))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentTrailing.close()
        horizontalAlignmentTrailing.move(to: CGPoint(x: 8, y: 5))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 8, y: 6))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 6, y: 6))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 6, y: 10))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 5, y: 10))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 5, y: 6))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 3, y: 6))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 3, y: 5))
        horizontalAlignmentTrailing.addLine(to: CGPoint(x: 8, y: 5))
        horizontalAlignmentTrailing.close()
        context.saveGState()
        UIColor(hue: 0.583, saturation: 0.095, brightness: 0.082, alpha: 1).setFill()
        horizontalAlignmentTrailing.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawHorizontalAlignmentCenter(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 15), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 11, height: 15), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 11, y: resizedFrame.height / 15)
        
        /// horizontalAlignmentCenter
        let horizontalAlignmentCenter = UIBezierPath()
        horizontalAlignmentCenter.move(to: CGPoint(x: 6, y: 0))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 6, y: 2))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 11, y: 2))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 11, y: 13))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 6, y: 13))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 6, y: 15))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 5, y: 15))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 5, y: 13))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 0, y: 13))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 0, y: 2))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 5, y: 2))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 5, y: 0))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 6, y: 0))
        horizontalAlignmentCenter.close()
        horizontalAlignmentCenter.move(to: CGPoint(x: 5, y: 3))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 1, y: 3))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 1, y: 12))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 5, y: 12))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 5, y: 3))
        horizontalAlignmentCenter.close()
        horizontalAlignmentCenter.move(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 6, y: 3))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 6, y: 12))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 10, y: 12))
        horizontalAlignmentCenter.addLine(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentCenter.close()
        context.saveGState()
        UIColor(hue: 0.583, saturation: 0.095, brightness: 0.082, alpha: 1).setFill()
        horizontalAlignmentCenter.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawHorizontalAlignmentLeft(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 15), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 11, height: 15), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 11, y: resizedFrame.height / 15)
        
        /// horizontalAlignmentLeft
        let horizontalAlignmentLeft = UIBezierPath()
        horizontalAlignmentLeft.move(to: CGPoint(x: 1, y: 0))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 1, y: 2))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 11, y: 2))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 11, y: 13))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 1, y: 13))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 1, y: 15))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 0, y: 15))
        horizontalAlignmentLeft.addLine(to: CGPoint.zero)
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 1, y: 0))
        horizontalAlignmentLeft.close()
        horizontalAlignmentLeft.move(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 1, y: 3))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 1, y: 12))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 10, y: 12))
        horizontalAlignmentLeft.addLine(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentLeft.close()
        context.saveGState()
        UIColor(hue: 0.583, saturation: 0.095, brightness: 0.082, alpha: 1).setFill()
        horizontalAlignmentLeft.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawHorizontalAlignmentLeading(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 11, height: 15), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 11, height: 15), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 11, y: resizedFrame.height / 15)
        
        /// horizontalAlignmentLeading
        let horizontalAlignmentLeading = UIBezierPath()
        horizontalAlignmentLeading.move(to: CGPoint(x: 1, y: 0))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 1, y: 2))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 11, y: 2))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 11, y: 13))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 1, y: 13))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 1, y: 15))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 0, y: 15))
        horizontalAlignmentLeading.addLine(to: CGPoint.zero)
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 1, y: 0))
        horizontalAlignmentLeading.close()
        horizontalAlignmentLeading.move(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 1, y: 3))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 1, y: 12))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 10, y: 12))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 10, y: 3))
        horizontalAlignmentLeading.close()
        horizontalAlignmentLeading.move(to: CGPoint(x: 5, y: 5))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 5, y: 9))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 7, y: 9))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 7, y: 10))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 4, y: 10))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 4, y: 5))
        horizontalAlignmentLeading.addLine(to: CGPoint(x: 5, y: 5))
        horizontalAlignmentLeading.close()
        context.saveGState()
        UIColor(hue: 0.583, saturation: 0.095, brightness: 0.082, alpha: 1).setFill()
        horizontalAlignmentLeading.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawListBulletIndent(color: UIColor = .black, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 24, height: 24), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 24, height: 24), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 24, y: resizedFrame.height / 24)
        
        /// Shape
        let shape = UIBezierPath()
        shape.move(to: CGPoint(x: 1.01, y: 1.99))
        shape.addCurve(to: CGPoint(x: 2.01, y: 1), controlPoint1: CGPoint(x: 1.56, y: 1.99), controlPoint2: CGPoint(x: 2.01, y: 1.55))
        shape.addCurve(to: CGPoint(x: 1.01, y: 0), controlPoint1: CGPoint(x: 2.01, y: 0.45), controlPoint2: CGPoint(x: 1.56, y: 0))
        shape.addCurve(to: CGPoint(x: 0, y: 1), controlPoint1: CGPoint(x: 0.45, y: 0), controlPoint2: CGPoint(x: 0, y: 0.45))
        shape.addCurve(to: CGPoint(x: 1.01, y: 1.99), controlPoint1: CGPoint(x: 0, y: 1.55), controlPoint2: CGPoint(x: 0.45, y: 1.99))
        shape.close()
        shape.move(to: CGPoint(x: 4.31, y: 1.72))
        shape.addLine(to: CGPoint(x: 13.69, y: 1.72))
        shape.addCurve(to: CGPoint(x: 14.42, y: 1), controlPoint1: CGPoint(x: 14.09, y: 1.72), controlPoint2: CGPoint(x: 14.42, y: 1.4))
        shape.addCurve(to: CGPoint(x: 13.69, y: 0.27), controlPoint1: CGPoint(x: 14.42, y: 0.6), controlPoint2: CGPoint(x: 14.09, y: 0.27))
        shape.addLine(to: CGPoint(x: 4.31, y: 0.27))
        shape.addCurve(to: CGPoint(x: 3.59, y: 1), controlPoint1: CGPoint(x: 3.91, y: 0.27), controlPoint2: CGPoint(x: 3.59, y: 0.59))
        shape.addCurve(to: CGPoint(x: 4.31, y: 1.72), controlPoint1: CGPoint(x: 3.59, y: 1.4), controlPoint2: CGPoint(x: 3.91, y: 1.72))
        shape.close()
        shape.move(to: CGPoint(x: 2.8, y: 6.25))
        shape.addCurve(to: CGPoint(x: 3.8, y: 5.25), controlPoint1: CGPoint(x: 3.35, y: 6.25), controlPoint2: CGPoint(x: 3.8, y: 5.8))
        shape.addCurve(to: CGPoint(x: 2.8, y: 4.25), controlPoint1: CGPoint(x: 3.8, y: 4.7), controlPoint2: CGPoint(x: 3.35, y: 4.25))
        shape.addCurve(to: CGPoint(x: 1.79, y: 5.25), controlPoint1: CGPoint(x: 2.24, y: 4.25), controlPoint2: CGPoint(x: 1.79, y: 4.7))
        shape.addCurve(to: CGPoint(x: 2.8, y: 6.25), controlPoint1: CGPoint(x: 1.79, y: 5.8), controlPoint2: CGPoint(x: 2.24, y: 6.25))
        shape.close()
        shape.move(to: CGPoint(x: 6.11, y: 5.98))
        shape.addLine(to: CGPoint(x: 15.48, y: 5.98))
        shape.addCurve(to: CGPoint(x: 16.21, y: 5.25), controlPoint1: CGPoint(x: 15.89, y: 5.98), controlPoint2: CGPoint(x: 16.21, y: 5.65))
        shape.addCurve(to: CGPoint(x: 15.48, y: 4.52), controlPoint1: CGPoint(x: 16.21, y: 4.85), controlPoint2: CGPoint(x: 15.89, y: 4.52))
        shape.addLine(to: CGPoint(x: 6.11, y: 4.52))
        shape.addCurve(to: CGPoint(x: 5.38, y: 5.25), controlPoint1: CGPoint(x: 5.7, y: 4.52), controlPoint2: CGPoint(x: 5.38, y: 4.85))
        shape.addCurve(to: CGPoint(x: 6.11, y: 5.98), controlPoint1: CGPoint(x: 5.38, y: 5.65), controlPoint2: CGPoint(x: 5.7, y: 5.98))
        shape.close()
        shape.move(to: CGPoint(x: 4.59, y: 10.5))
        shape.addCurve(to: CGPoint(x: 5.59, y: 9.5), controlPoint1: CGPoint(x: 5.14, y: 10.5), controlPoint2: CGPoint(x: 5.59, y: 10.05))
        shape.addCurve(to: CGPoint(x: 4.59, y: 8.5), controlPoint1: CGPoint(x: 5.59, y: 8.95), controlPoint2: CGPoint(x: 5.14, y: 8.5))
        shape.addCurve(to: CGPoint(x: 3.58, y: 9.5), controlPoint1: CGPoint(x: 4.03, y: 8.5), controlPoint2: CGPoint(x: 3.58, y: 8.95))
        shape.addCurve(to: CGPoint(x: 4.59, y: 10.5), controlPoint1: CGPoint(x: 3.58, y: 10.05), controlPoint2: CGPoint(x: 4.03, y: 10.5))
        shape.close()
        shape.move(to: CGPoint(x: 7.9, y: 10.23))
        shape.addLine(to: CGPoint(x: 17.28, y: 10.23))
        shape.addCurve(to: CGPoint(x: 18, y: 9.5), controlPoint1: CGPoint(x: 17.68, y: 10.23), controlPoint2: CGPoint(x: 18, y: 9.91))
        shape.addCurve(to: CGPoint(x: 17.28, y: 8.78), controlPoint1: CGPoint(x: 18, y: 9.1), controlPoint2: CGPoint(x: 17.68, y: 8.78))
        shape.addLine(to: CGPoint(x: 7.9, y: 8.78))
        shape.addCurve(to: CGPoint(x: 7.17, y: 9.5), controlPoint1: CGPoint(x: 7.49, y: 8.78), controlPoint2: CGPoint(x: 7.17, y: 9.1))
        shape.addCurve(to: CGPoint(x: 7.9, y: 10.23), controlPoint1: CGPoint(x: 7.17, y: 9.9), controlPoint2: CGPoint(x: 7.49, y: 10.23))
        shape.close()
        context.saveGState()
        context.translateBy(x: 3, y: 7.5)
        color.setFill()
        shape.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawSliderHorizontal(color: UIColor = .black, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 24, height: 24), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 24, height: 24), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 24, y: resizedFrame.height / 24)
        
        /// �
        let layer = UIBezierPath()
        layer.move(to: CGPoint(x: 9, y: 18))
        layer.addCurve(to: CGPoint(x: 12.48, y: 17.29), controlPoint1: CGPoint(x: 10.23, y: 18), controlPoint2: CGPoint(x: 11.4, y: 17.76))
        layer.addCurve(to: CGPoint(x: 15.35, y: 15.34), controlPoint1: CGPoint(x: 13.57, y: 16.82), controlPoint2: CGPoint(x: 14.52, y: 16.17))
        layer.addCurve(to: CGPoint(x: 17.3, y: 12.48), controlPoint1: CGPoint(x: 16.18, y: 14.52), controlPoint2: CGPoint(x: 16.83, y: 13.56))
        layer.addCurve(to: CGPoint(x: 18, y: 9), controlPoint1: CGPoint(x: 17.77, y: 11.39), controlPoint2: CGPoint(x: 18, y: 10.23))
        layer.addCurve(to: CGPoint(x: 17.3, y: 5.52), controlPoint1: CGPoint(x: 18, y: 7.77), controlPoint2: CGPoint(x: 17.77, y: 6.61))
        layer.addCurve(to: CGPoint(x: 15.35, y: 2.65), controlPoint1: CGPoint(x: 16.83, y: 4.44), controlPoint2: CGPoint(x: 16.18, y: 3.48))
        layer.addCurve(to: CGPoint(x: 12.47, y: 0.7), controlPoint1: CGPoint(x: 14.52, y: 1.82), controlPoint2: CGPoint(x: 13.56, y: 1.17))
        layer.addCurve(to: CGPoint(x: 8.99, y: 0), controlPoint1: CGPoint(x: 11.39, y: 0.23), controlPoint2: CGPoint(x: 10.23, y: 0))
        layer.addCurve(to: CGPoint(x: 5.53, y: 0.7), controlPoint1: CGPoint(x: 7.77, y: 0), controlPoint2: CGPoint(x: 6.61, y: 0.23))
        layer.addCurve(to: CGPoint(x: 2.65, y: 2.65), controlPoint1: CGPoint(x: 4.44, y: 1.17), controlPoint2: CGPoint(x: 3.48, y: 1.82))
        layer.addCurve(to: CGPoint(x: 0.7, y: 5.52), controlPoint1: CGPoint(x: 1.82, y: 3.48), controlPoint2: CGPoint(x: 1.17, y: 4.44))
        layer.addCurve(to: CGPoint(x: 0, y: 9), controlPoint1: CGPoint(x: 0.23, y: 6.61), controlPoint2: CGPoint(x: 0, y: 7.77))
        layer.addCurve(to: CGPoint(x: 0.71, y: 12.48), controlPoint1: CGPoint(x: 0, y: 10.23), controlPoint2: CGPoint(x: 0.24, y: 11.39))
        layer.addCurve(to: CGPoint(x: 2.66, y: 15.34), controlPoint1: CGPoint(x: 1.18, y: 13.56), controlPoint2: CGPoint(x: 1.83, y: 14.52))
        layer.addCurve(to: CGPoint(x: 5.53, y: 17.29), controlPoint1: CGPoint(x: 3.48, y: 16.17), controlPoint2: CGPoint(x: 4.44, y: 16.82))
        layer.addCurve(to: CGPoint(x: 9, y: 18), controlPoint1: CGPoint(x: 6.61, y: 17.76), controlPoint2: CGPoint(x: 7.77, y: 18))
        layer.close()
        layer.move(to: CGPoint(x: 7.4, y: 13.97))
        layer.addCurve(to: CGPoint(x: 6.9, y: 13.78), controlPoint1: CGPoint(x: 7.21, y: 13.97), controlPoint2: CGPoint(x: 7.04, y: 13.91))
        layer.addCurve(to: CGPoint(x: 6.69, y: 13.29), controlPoint1: CGPoint(x: 6.76, y: 13.65), controlPoint2: CGPoint(x: 6.69, y: 13.48))
        layer.addCurve(to: CGPoint(x: 6.9, y: 12.81), controlPoint1: CGPoint(x: 6.69, y: 13.1), controlPoint2: CGPoint(x: 6.76, y: 12.94))
        layer.addCurve(to: CGPoint(x: 7.4, y: 12.6), controlPoint1: CGPoint(x: 7.04, y: 12.67), controlPoint2: CGPoint(x: 7.21, y: 12.6))
        layer.addLine(to: CGPoint(x: 8.49, y: 12.6))
        layer.addLine(to: CGPoint(x: 8.49, y: 8.68))
        layer.addLine(to: CGPoint(x: 7.56, y: 8.68))
        layer.addCurve(to: CGPoint(x: 7.06, y: 8.49), controlPoint1: CGPoint(x: 7.36, y: 8.68), controlPoint2: CGPoint(x: 7.19, y: 8.61))
        layer.addCurve(to: CGPoint(x: 6.85, y: 7.99), controlPoint1: CGPoint(x: 6.92, y: 8.36), controlPoint2: CGPoint(x: 6.85, y: 8.19))
        layer.addCurve(to: CGPoint(x: 7.06, y: 7.51), controlPoint1: CGPoint(x: 6.85, y: 7.81), controlPoint2: CGPoint(x: 6.92, y: 7.65))
        layer.addCurve(to: CGPoint(x: 7.56, y: 7.31), controlPoint1: CGPoint(x: 7.19, y: 7.38), controlPoint2: CGPoint(x: 7.36, y: 7.31))
        layer.addLine(to: CGPoint(x: 9.28, y: 7.31))
        layer.addCurve(to: CGPoint(x: 9.84, y: 7.56), controlPoint1: CGPoint(x: 9.52, y: 7.31), controlPoint2: CGPoint(x: 9.71, y: 7.4))
        layer.addCurve(to: CGPoint(x: 10.03, y: 8.19), controlPoint1: CGPoint(x: 9.96, y: 7.72), controlPoint2: CGPoint(x: 10.03, y: 7.93))
        layer.addLine(to: CGPoint(x: 10.03, y: 12.6))
        layer.addLine(to: CGPoint(x: 11.08, y: 12.6))
        layer.addCurve(to: CGPoint(x: 11.58, y: 12.81), controlPoint1: CGPoint(x: 11.28, y: 12.6), controlPoint2: CGPoint(x: 11.45, y: 12.67))
        layer.addCurve(to: CGPoint(x: 11.79, y: 13.29), controlPoint1: CGPoint(x: 11.72, y: 12.94), controlPoint2: CGPoint(x: 11.79, y: 13.1))
        layer.addCurve(to: CGPoint(x: 11.58, y: 13.78), controlPoint1: CGPoint(x: 11.79, y: 13.48), controlPoint2: CGPoint(x: 11.72, y: 13.65))
        layer.addCurve(to: CGPoint(x: 11.08, y: 13.97), controlPoint1: CGPoint(x: 11.45, y: 13.91), controlPoint2: CGPoint(x: 11.28, y: 13.97))
        layer.addLine(to: CGPoint(x: 7.4, y: 13.97))
        layer.close()
        layer.move(to: CGPoint(x: 8.94, y: 5.87))
        layer.addCurve(to: CGPoint(x: 8.06, y: 5.51), controlPoint1: CGPoint(x: 8.59, y: 5.87), controlPoint2: CGPoint(x: 8.3, y: 5.75))
        layer.addCurve(to: CGPoint(x: 7.71, y: 4.65), controlPoint1: CGPoint(x: 7.83, y: 5.28), controlPoint2: CGPoint(x: 7.71, y: 4.99))
        layer.addCurve(to: CGPoint(x: 8.06, y: 3.77), controlPoint1: CGPoint(x: 7.71, y: 4.3), controlPoint2: CGPoint(x: 7.83, y: 4.01))
        layer.addCurve(to: CGPoint(x: 8.94, y: 3.42), controlPoint1: CGPoint(x: 8.3, y: 3.54), controlPoint2: CGPoint(x: 8.59, y: 3.42))
        layer.addCurve(to: CGPoint(x: 9.79, y: 3.77), controlPoint1: CGPoint(x: 9.27, y: 3.42), controlPoint2: CGPoint(x: 9.55, y: 3.54))
        layer.addCurve(to: CGPoint(x: 10.15, y: 4.65), controlPoint1: CGPoint(x: 10.03, y: 4.01), controlPoint2: CGPoint(x: 10.15, y: 4.3))
        layer.addCurve(to: CGPoint(x: 9.79, y: 5.51), controlPoint1: CGPoint(x: 10.15, y: 4.99), controlPoint2: CGPoint(x: 10.03, y: 5.28))
        layer.addCurve(to: CGPoint(x: 8.94, y: 5.87), controlPoint1: CGPoint(x: 9.55, y: 5.75), controlPoint2: CGPoint(x: 9.27, y: 5.87))
        layer.close()
        context.saveGState()
        context.translateBy(x: 3, y: 3)
        color.setFill()
        layer.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    class func drawChevronDown(color: UIColor = .black, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 16, height: 16), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 16, height: 16), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 16, y: resizedFrame.height / 16)
        
        /// Path
        let path = UIBezierPath()
        path.move(to: CGPoint(x: 5, y: 6))
        path.addCurve(to: CGPoint(x: 5.55, y: 5.75), controlPoint1: CGPoint(x: 5.21, y: 6), controlPoint2: CGPoint(x: 5.4, y: 5.92))
        path.addLine(to: CGPoint(x: 9.8, y: 1.28))
        path.addCurve(to: CGPoint(x: 10, y: 0.75), controlPoint1: CGPoint(x: 9.93, y: 1.14), controlPoint2: CGPoint(x: 10, y: 0.96))
        path.addCurve(to: CGPoint(x: 9.29, y: 0), controlPoint1: CGPoint(x: 10, y: 0.33), controlPoint2: CGPoint(x: 9.69, y: 0))
        path.addCurve(to: CGPoint(x: 8.77, y: 0.23), controlPoint1: CGPoint(x: 9.1, y: 0), controlPoint2: CGPoint(x: 8.91, y: 0.09))
        path.addLine(to: CGPoint(x: 5, y: 4.21))
        path.addLine(to: CGPoint(x: 1.23, y: 0.23))
        path.addCurve(to: CGPoint(x: 0.71, y: 0), controlPoint1: CGPoint(x: 1.09, y: 0.09), controlPoint2: CGPoint(x: 0.91, y: 0))
        path.addCurve(to: CGPoint(x: 0, y: 0.75), controlPoint1: CGPoint(x: 0.31, y: 0), controlPoint2: CGPoint(x: 0, y: 0.33))
        path.addCurve(to: CGPoint(x: 0.2, y: 1.28), controlPoint1: CGPoint(x: 0, y: 0.96), controlPoint2: CGPoint(x: 0.07, y: 1.14))
        path.addLine(to: CGPoint(x: 4.45, y: 5.75))
        path.addCurve(to: CGPoint(x: 5, y: 6), controlPoint1: CGPoint(x: 4.62, y: 5.92), controlPoint2: CGPoint(x: 4.8, y: 6))
        path.close()
        context.saveGState()
        context.translateBy(x: 3, y: 5.5)
        color.setFill()
        path.fill()
        context.restoreGState()
        
        context.restoreGState()
    }
    
    
    //MARK: - Canvas Images
    
    /// Icons
    
    class func imageOfColorGridLarge() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 32, height: 16), false, 0)
        IconKit.drawColorGridLarge()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfVerticalAlignmentTop() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 15, height: 11), false, 0)
        IconKit.drawVerticalAlignmentTop()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfVerticalAlignmentCenter() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 15, height: 11), false, 0)
        IconKit.drawVerticalAlignmentCenter()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfVerticalAlignmentBottom() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 15, height: 11), false, 0)
        IconKit.drawVerticalAlignmentBottom()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfVerticalAlignmentFill() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 11, height: 11), false, 0)
        IconKit.drawVerticalAlignmentFill()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfHorizontalAlignmentFill() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 11, height: 11), false, 0)
        IconKit.drawHorizontalAlignmentFill()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfHorizontalAlignmentRight() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 11, height: 15), false, 0)
        IconKit.drawHorizontalAlignmentRight()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfHorizontalAlignmentTrailing() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 11, height: 15), false, 0)
        IconKit.drawHorizontalAlignmentTrailing()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfHorizontalAlignmentCenter() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 11, height: 15), false, 0)
        IconKit.drawHorizontalAlignmentCenter()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfHorizontalAlignmentLeft() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 11, height: 15), false, 0)
        IconKit.drawHorizontalAlignmentLeft()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfHorizontalAlignmentLeading() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 11, height: 15), false, 0)
        IconKit.drawHorizontalAlignmentLeading()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfListBulletIndent() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 24, height: 24), false, 0)
        IconKit.drawListBulletIndent()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfSliderHorizontal() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 24, height: 24), false, 0)
        IconKit.drawSliderHorizontal()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    class func imageOfChevronDown() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 16, height: 16), false, 0)
        IconKit.drawChevronDown()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    
    //MARK: - Resizing Behavior
    
    enum ResizingBehavior {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.
        
        func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }
            
            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)
            
            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }
            
            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
    
    
}
